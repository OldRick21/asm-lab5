section .rodata
; Ядро Гаусса 3x3 (нормализовано делением на 16)
; Расположение в памяти:
; [1, 2, 1] - строка 0
; [2, 4, 2] - строка 1
; [1, 2, 1] - строка 2
kernel:
    db 1, 2, 1    ; Строка 0 ядра (kx = -1, 0, +1)
    db 2, 4, 2    ; Строка 1 ядра
    db 1, 2, 1    ; Строка 2 ядра

section .text
global gaussian_blur_asm

; Функция размытия по Гауссу
; Параметры:
;   rdi - указатель на временный буфер (с расширенными границами)
;   rsi - указатель на выходной буфер
;   rdx - ширина временного буфера (temp_width)
;   rcx - высота временного буфера (temp_height)
;   r8  - ширина выходного изображения
;   r9  - высота выходного изображения
gaussian_blur_asm:
    push rbp
    mov rbp, rsp
    ; Сохраняем callee-saved регистры по соглашению ABI
    push rbx                ; Третий базовый регистр (будем использовать для каналов)
    push r12                ; Индекс строки (y)
    push r13                ; Индекс столбца (x)
    push r14                ; Аккумулятор суммы (sum)
    push r15                ; Индекс строки ядра (ky)
    push r10                ; Временное хранение указателей

    ; Переназначение параметров для удобства работы
    mov r10, rsi            ; r10 = output buffer (сохраняем на время)
    mov rsi, rdx            ; rsi = temp_width (новый параметр)
    mov r11, rdi            ; r11 = temp buffer (новый указатель)
    mov rdi, r8             ; rdi = width (основная ширина)
    mov r8, r9              ; r8 = height (основная высота)
    mov r9, rcx             ; r9 = temp_height (высота временного буфера)

    xor ebx, ebx            ; ebx = c (счетчик каналов 0..2)

; Внешний цикл по цветовым каналам (R, G, B)
.loop_channels:
    cmp ebx, 3              ; Проверка завершения обработки каналов
    jge .end_loop_channels  ; Выход если все каналы обработаны

    xor r12, r12            ; r12 = y (счетчик строк 0..height-1)

; Цикл по строкам выходного изображения
.loop_y:
    cmp r12, r8             ; Сравнение с высотой изображения
    jge .end_loop_y         ; Переход к следующему каналу если строки закончились

    xor r13, r13            ; r13 = x (счетчик столбцов 0..width-1)

; Цикл по столбцам выходного изображения
.loop_x:
    cmp r13, rdi            ; Сравнение с шириной изображения
    jge .end_loop_x         ; Переход к следующей строке если столбцы закончились

    xor r14d, r14d          ; r14d = sum = 0 (обнуление суммы)

    mov r15d, -1            ; r15d = ky (-1, 0, +1)

; Цикл по строкам ядра Гаусса (ky)
.loop_ky:
    cmp r15d, 1             ; Проверка границ ядра по вертикали
    jg .end_loop_ky         ; Выход при ky > 1

    mov eax, -1             ; eax = kx (-1, 0, +1)

; Цикл по столбцам ядра Гаусса (kx)
.loop_kx:
    cmp eax, 1              ; Проверка границ ядра по горизонтали
    jg .end_loop_kx         ; Выход при kx > 1

    ;----------------------------------------------------------
    ; Вычисление координат во временном буфере с учетом границ
    ;----------------------------------------------------------
    
    ; Вычисление pos_temp_y = clamp(y + 1 + ky, 0, temp_height-1)
    lea ecx, [r12 + 1]      ; ecx = y + 1 (так как временный буфер больше на 1 с каждой стороны)
    add ecx, r15d           ; ecx = y + 1 + ky
    ; Обработка выхода за верхнюю границу
    cmp ecx, 0
    jge .y_ok1
    xor ecx, ecx            ; Если < 0, устанавливаем 0
.y_ok1:
    ; Обработка выхода за нижнюю границу
    cmp ecx, r9d            ; Сравнение с temp_height
    jl .y_ok2
    mov ecx, r9d            ; Если >= temp_height, берем temp_height-1
    dec ecx
.y_ok2:

    ; Вычисление pos_temp_x = clamp(x + 1 + kx, 0, temp_width-1)
    lea edx, [r13 + 1]      ; edx = x + 1
    add edx, eax            ; edx = x + 1 + kx
    ; Обработка выхода за левую границу
    cmp edx, 0
    jge .x_ok1
    xor edx, edx            ; Если < 0, устанавливаем 0
.x_ok1:
    ; Обработка выхода за правую границу
    cmp edx, esi            ; Сравнение с temp_width
    jl .x_ok2
    mov edx, esi            ; Если >= temp_width, берем temp_width-1
    dec edx
.x_ok2:

    ;----------------------------------------------------------
    ; Получение значения пикселя из временного буфера
    ;----------------------------------------------------------
    ; Формула адреса: temp[(pos_temp_y * temp_width + pos_temp_x) * 3 + c]
    imul ecx, esi           ; ecx = pos_temp_y * temp_width
    add ecx, edx            ; ecx += pos_temp_x
    imul ecx, 3             ; ecx *= 3 (3 байта на пиксель)
    add ecx, ebx            ; ecx += c (текущий канал)
    ; Загрузка значения пикселя (1 байт)
    movzx edx, byte [r11 + rcx] ; edx = temp_pixel_value

    ;----------------------------------------------------------
    ; Получение коэффициента ядра Гаусса
    ;----------------------------------------------------------
    ; Формула индекса: (ky + 1) * 3 + (kx + 1)
    mov ecx, r15d           ; ky
    add ecx, 1              ; ky + 1 (преобразуем -1..1 в 0..2)
    imul ecx, 3             ; (ky+1) * 3 (смещение к нужной строке ядра)
    add ecx, eax            ; + kx
    add ecx, 1              ; +1 (преобразуем kx -1..1 в 0..2)
    ; Загрузка коэффициента из памяти (1 байт)
    movzx ecx, byte [kernel + rcx] ; ecx = kernel_value

    ;----------------------------------------------------------
    ; Накопление суммы произведений
    ;----------------------------------------------------------
    imul edx, ecx           ; edx = pixel_value * kernel_value
    add r14d, edx           ; sum += edx

    inc eax                 ; Увеличиваем kx
    jmp .loop_kx            ; Повторяем внутренний цикл по kx

.end_loop_kx:
    inc r15d                ; Увеличиваем ky
    jmp .loop_ky            ; Повторяем цикл по ky

.end_loop_ky:
    ;----------------------------------------------------------
    ; Нормализация суммы и запись результата
    ;----------------------------------------------------------
    ; sum = (sum + 8) >> 4 (эквивалентно делению на 16 с округлением)
    add r14d, 8             ; Добавляем 8 для правильного округления
    shr r14d, 4             ; Делим на 16 сдвигом вправо

    ; Вычисление адреса в выходном буфере
    ; Формула: output[(y * width + x) * 3 + c]
    mov ecx, r12d           ; y
    imul ecx, edi           ; y * width
    add ecx, r13d           ; + x
    imul ecx, 3             ; * 3 (3 канала)
    add ecx, ebx            ; + c (текущий канал)
    ; Запись результата (младший байт r14d)
    mov byte [r10 + rcx], r14b

    inc r13                 ; Увеличиваем x
    jmp .loop_x             ; Повторяем цикл по x

.end_loop_x:
    inc r12                 ; Увеличиваем y
    jmp .loop_y             ; Повторяем цикл по y

.end_loop_y:
    inc ebx                 ; Увеличиваем c (переходим к следующему каналу)
    jmp .loop_channels      ; Повторяем цикл по каналам

.end_loop_channels:
    ;----------------------------------------------------------
    ; Восстановление регистров и возврат из функции
    ;----------------------------------------------------------
    pop r10                 ; Восстанавливаем сохраненные регистры
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    pop rbp
    ret                     ; Возврат управления вызывающему коду